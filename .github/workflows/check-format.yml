name: Code Format Check

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

jobs:
  clang-format-check:
    name: Check Code Formatting
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      
    - name: Install clang-format
      run: |
        echo "Installing clang-format..."
        sudo apt-get update
        sudo apt-get install -y clang-format
        echo "clang-format version: $(clang-format --version)"
        
    - name: Find C++ files
      id: find_files
      run: |
        echo "Scanning for C++ files..."
        CPP_FILES=$(find . -name "*.cpp" -o -name "*.h" -o -name "*.hpp" -o -name "*.c" -o -name "*.cc" -o -name "*.cxx" | grep -v "gtest" | grep -v "build/" | sort)
        CPP_COUNT=$(echo "$CPP_FILES" | grep -c "^" || true)
        echo "Found $CPP_COUNT C/C++ files"
        echo "files<<EOF" >> $GITHUB_OUTPUT
        echo "$CPP_FILES" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
    - name: Check formatting with error patterns
      id: check_format
      run: |
        ERROR_COUNT=0
        UNFORMATTED_FILES=""
        
        # Паттерны ошибок для clang-format
        ERROR_PATTERNS=(
          "POINTER_ALIGNMENT"
          "REFERENCE_ALIGNMENT" 
          "BRACE_PLACEMENT"
          "SPACE_BEFORE_PAREN"
          "SPACE_AROUND_OPERATORS"
          "INDENTATION"
          "TRAILING_WHITESPACE"
          "ACCESS_SPECIFIER"
          "NAMESPACE_INDENT"
          "LINE_LENGTH"
          "COMMENT_SPACING"
          "TAB_CHARACTER"
          "INCLUDE_ORDER"
          "ELSE_NEWLINE"
          "EMPTY_BLOCK"
          "TEMPLATE_FORMATTING"
          "LAMBDA_FORMATTING"
        )
        
        while IFS= read -r file; do
          if [ -n "$file" ]; then
            echo ""
            echo "FILE: $file"
            echo "----------------------------------------"
            
            # Проверяем форматирование и получаем ошибки
            clang-format -n "$file" 2>clang_output.tmp || true
            
            # Анализируем ошибки clang-format
            if [ -s clang_output.tmp ]; then
              ERROR_COUNT=$((ERROR_COUNT + 1))
              UNFORMATTED_FILES="$UNFORMATTED_FILES\n- $file"
              
              echo "ERROR_PATTERN: FORMATTING_VIOLATION"
              echo "FILE: $file"
              
              # Парсим вывод clang-format и классифицируем ошибки
              while IFS= read -r error_line; do
                if echo "$error_line" | grep -q "code should be clang-formatted"; then
                  LINE_NUM=$(echo "$error_line" | grep -o ":[0-9]*:" | grep -o "[0-9]*")
                  COL_NUM=$(echo "$error_line" | grep -o ":[0-9]*:" | tail -1 | grep -o "[0-9]*")
                  
                  # Получаем конкретную строку из файла
                  PROBLEM_LINE=$(sed -n "${LINE_NUM}p" "$file")
                  FIXED_LINE=$(clang-format "$file" | sed -n "${LINE_NUM}p")
                  
                  # Классифицируем тип ошибки
                  ERROR_TYPE="UNKNOWN"
                  if echo "$PROBLEM_LINE" | grep -q "\*\*[a-zA-Z]"; then
                    ERROR_TYPE="POINTER_ALIGNMENT"
                    ERROR_DESC="Pointer alignment: '**' should be adjacent to type or variable name"
                    FIX_DESC="Remove space between ** and variable name"
                  elif echo "$PROBLEM_LINE" | grep -q "char \*\*"; then
                    ERROR_TYPE="POINTER_ALIGNMENT"
                    ERROR_DESC="Pointer alignment: 'char **' should be 'char**'"
                    FIX_DESC="Remove space between * and variable name"
                  elif echo "$PROBLEM_LINE" | grep -q " \*[a-zA-Z]"; then
                    ERROR_TYPE="POINTER_ALIGNMENT"
                    ERROR_DESC="Pointer alignment: Space between * and variable name"
                    FIX_DESC="Remove space: '*var' should be '*var'"
                  elif echo "$PROBLEM_LINE" | grep -q "int \*"; then
                    ERROR_TYPE="POINTER_ALIGNMENT"
                    ERROR_DESC="Pointer alignment: 'int *' should be 'int*'"
                    FIX_DESC="Move '*' to the type"
                  elif echo "$PROBLEM_LINE" | grep -q "&[a-zA-Z]"; then
                    ERROR_TYPE="REFERENCE_ALIGNMENT"
                    ERROR_DESC="Reference alignment: '&' should be adjacent to type"
                    FIX_DESC="Move '&' to the type: 'int& var'"
                  elif echo "$PROBLEM_LINE" | grep -q "[a-zA-Z0-9)] {"; then
                    ERROR_TYPE="BRACE_PLACEMENT"
                    ERROR_DESC="Brace placement: Opening brace should be on the same line"
                    FIX_DESC="Move '{' to the same line: ') {'"
                  elif echo "$PROBLEM_LINE" | grep -q "^[a-zA-Z].*)\s*$"; then
                    ERROR_TYPE="BRACE_PLACEMENT"
                    ERROR_DESC="Brace placement: Opening brace on new line"
                    FIX_DESC="Move '{' to the previous line"
                  elif echo "$PROBLEM_LINE" | grep -q "if("; then
                    ERROR_TYPE="SPACE_BEFORE_PAREN"
                    ERROR_DESC="Space before parenthesis: Missing space between 'if' and '('"
                    FIX_DESC="Add space: 'if ('"
                  elif echo "$PROBLEM_LINE" | grep -q "for("; then
                    ERROR_TYPE="SPACE_BEFORE_PAREN"
                    ERROR_DESC="Space before parenthesis: Missing space between 'for' and '('"
                    FIX_DESC="Add space: 'for ('"
                  elif echo "$PROBLEM_LINE" | grep -q "while("; then
                    ERROR_TYPE="SPACE_BEFORE_PAREN"
                    ERROR_DESC="Space before parenthesis: Missing space between 'while' and '('"
                    FIX_DESC="Add space: 'while ('"
                  elif echo "$PROBLEM_LINE" | grep -q "switch("; then
                    ERROR_TYPE="SPACE_BEFORE_PAREN"
                    ERROR_DESC="Space before parenthesis: Missing space between 'switch' and '('"
                    FIX_DESC="Add space: 'switch ('"
                  elif echo "$PROBLEM_LINE" | grep -q "catch("; then
                    ERROR_TYPE="SPACE_BEFORE_PAREN"
                    ERROR_DESC="Space before parenthesis: Missing space between 'catch' and '('"
                    FIX_DESC="Add space: 'catch ('"
                  elif echo "$PROBLEM_LINE" | grep -q "\s\+$"; then
                    ERROR_TYPE="TRAILING_WHITESPACE"
                    ERROR_DESC="Trailing whitespace at end of line"
                    FIX_DESC="Remove spaces at the end of line"
                  elif echo "$PROBLEM_LINE" | grep -q "^public:"; then
                    ERROR_TYPE="ACCESS_SPECIFIER"
                    ERROR_DESC="Access specifier indentation: 'public:' should be indented"
                    FIX_DESC="Add indentation (1 or 2 spaces)"
                  elif echo "$PROBLEM_LINE" | grep -q "^private:"; then
                    ERROR_TYPE="ACCESS_SPECIFIER"
                    ERROR_DESC="Access specifier indentation: 'private:' should be indented"
                    FIX_DESC="Add indentation (1 or 2 spaces)"
                  elif echo "$PROBLEM_LINE" | grep -q "^protected:"; then
                    ERROR_TYPE="ACCESS_SPECIFIER"
                    ERROR_DESC="Access specifier indentation: 'protected:' should be indented"
                    FIX_DESC="Add indentation (1 or 2 spaces)"
                  elif echo "$PROBLEM_LINE" | grep -q "^namespace.*{"; then
                    ERROR_TYPE="NAMESPACE_INDENT"
                    ERROR_DESC="Namespace indentation: Content should be indented"
                    FIX_DESC="Indent namespace content"
                  elif echo "$PROBLEM_LINE" | grep -q "^class.*{"; then
                    ERROR_TYPE="CLASS_FORMATTING"
                    ERROR_DESC="Class definition formatting"
                    FIX_DESC="Check class brace placement and indentation"
                  elif echo "$PROBLEM_LINE" | grep -q "^\s*for.*;.*;.*{$"; then
                    ERROR_TYPE="SPACE_AROUND_OPERATORS"
                    ERROR_DESC="For loop formatting: Missing spaces around operators"
                    FIX_DESC="Add spaces: 'for (int i = 0; i < n; i++)'"
                  elif echo "$PROBLEM_LINE" | grep -q "^\s*if.*==.*"; then
                    ERROR_TYPE="SPACE_AROUND_OPERATORS"
                    ERROR_DESC="Operator spacing: Missing spaces around '=='"
                    FIX_DESC="Add spaces: 'x == y'"
                  elif echo "$PROBLEM_LINE" | grep -q "^\s*if.*!="; then
                    ERROR_TYPE="SPACE_AROUND_OPERATORS"
                    ERROR_DESC="Operator spacing: Missing spaces around '!='"
                    FIX_DESC="Add spaces: 'x != y'"
                  elif echo "$PROBLEM_LINE" | grep -q "^\s*//[^ ]"; then
                    ERROR_TYPE="COMMENT_SPACING"
                    ERROR_DESC="Comment spacing: Missing space after //"
                    FIX_DESC="Add space: '// comment'"
                  elif echo "$PROBLEM_LINE" | grep -q "\t"; then
                    ERROR_TYPE="TAB_CHARACTER"
                    ERROR_DESC="Tab character detected. Use spaces for indentation"
                    FIX_DESC="Replace tabs with spaces (2 spaces per tab)"
                  elif echo "$PROBLEM_LINE" | grep -q "^\s*}[^,]?else"; then
                    ERROR_TYPE="ELSE_NEWLINE"
                    ERROR_DESC="Else statement formatting"
                    FIX_DESC="Format as: '} else {'"
                  elif echo "$PROBLEM_LINE" | grep -q "template<"; then
                    ERROR_TYPE="TEMPLATE_FORMATTING"
                    ERROR_DESC="Template declaration formatting"
                    FIX_DESC="Add space: 'template <typename T>'"
                  elif echo "$PROBLEM_LINE" | grep -q "\[&\]"; then
                    ERROR_TYPE="LAMBDA_FORMATTING"
                    ERROR_DESC="Lambda capture formatting"
                    FIX_DESC="Check lambda capture syntax"
                  fi
                  
                  echo "  ERROR_PATTERN: $ERROR_TYPE"
                  echo "  ERROR_FILE: $file"
                  echo "  ERROR_LINE: $LINE_NUM"
                  echo "  ERROR_COLUMN: $COL_NUM"
                  echo "  ERROR_DESC: $ERROR_DESC"
                  echo "  ERROR_CODE: \"$PROBLEM_LINE\""
                  echo "  FIXED_CODE: \"$FIXED_LINE\""
                  echo "  HOW_TO_FIX: $FIX_DESC"
                  echo "  FIX_COMMAND: clang-format -i $file"
                  echo "---"
                fi
              done < clang_output.tmp
            else
              echo "  PASS: $file is properly formatted"
            fi
          fi
        done < <(echo "${{ steps.find_files.outputs.files }}")
        
        if [ $ERROR_COUNT -gt 0 ]; then
          echo ""
          echo "========================================="
          echo "ERROR_PATTERN: FORMATTING_FAILURE"
          echo "ERROR_SUMMARY: $ERROR_COUNT files need formatting"
          echo "ERROR_FILES:"
          printf "%b\n" "$UNFORMATTED_FILES"
          echo "========================================="
          echo ""
          echo "SEARCHABLE ERROR PATTERNS:"
          echo "-----------------------------------------"
          for pattern in "${ERROR_PATTERNS[@]}"; do
            echo "  grep -n \"ERROR_PATTERN: $pattern\" output.txt"
          done
          echo "-----------------------------------------"
          echo ""
          echo "QUICK FIX:"
          echo "  find . -name '*.cpp' -o -name '*.h' -o -name '*.hpp' | xargs clang-format -i"
          echo ""
          exit 1
        else
          echo ""
          echo "========================================="
          echo "FORMATTING_CHECK: SUCCESS"
          echo "All files are properly formatted"
          echo "========================================="
        fi